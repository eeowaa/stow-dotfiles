#!/bin/sh
progname="git visit"
usage="Usage: $progname [OPTION]... [FILE[:LINE]]"
moreinfo="Try \`$progname -h' for more info"
die() {
    if test -t 0
    then echo "$*"
    else cat
    fi >&2
    exit 1
}
browse() {
    case `uname -s` in
    Linux)
        xdg-open "$1" ;;
    Darwin)
        open "$1" ;;
    CYGWIN_NT*)
        cygstart -o "$1" ;;
    MINGW*|MSYS*)
        start '' "$1" ;;
    *)  ${BROWSER:?} "$1" ;;
    esac
}
browse_github() {
    # Strip the trailing '.git' from the remote URL
    remote_url=`expr "$remote_url" : '\(.*\)\.git$'`

    # Determine what we want to visit
    case $# in
    0)  if test "X$branch" = "X$remote_HEAD"
        then 
            # Homepage of repo
            url=$remote_url
        else
            # Tree of alternate branch
            url=$remote_url/tree/$branch
        fi ;;
    1)  file=`echo "X$1" | sed -e 's/^X//' -e 's/:[0-9]*$//'`
        line=`expr "X$1" : 'X.*:\([0-9]*\)$'`

        # Specific file, potentially with line number
        url=$remote_url/blob/$branch/$GIT_PREFIX$file
        test "X$line" = X || url="$url#L$line" ;;
    *)  die <<EOF
$usage
$moreinfo
EOF
    esac

    # Visit the darn thing!
    browse "$url"
}
browse_gitlab() {
    : stub
}
browse_bitbucket() {
    # Strip the trailing '.git' from the remote URL
    remote_url=`expr "$remote_url" : '\(.*\)\.git$'`

    # Determine what we want to visit
    case $# in
    0)  if test "X$branch" = "X$remote_HEAD"
        then
            # Homepage of repo
            url=$remote_url
        else
            # Tree of alternate branch
            url=$remote_url/src/$branch
        fi ;;
    1)  file=`echo "X$1" | sed -e 's/^X//' -e 's/:[0-9]*$//'`
        line=`expr "X$1" : 'X.*:\([0-9]*\)$'`

        # Specific file, potentially with line number
        url=$remote_url/src/$branch/$GIT_PREFIX$file
        test "X$line" = X || url="$url#lines-$line" ;;
    *)  die <<EOF
$usage
$moreinfo
EOF
    esac

    # Visit the darn thing!
    browse "$url"
}
browse_codecommit() {
    : stub
}
browse_cgit() {
    : stub
    # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
}

# Parse command line arguments
branch= remote= file= line=
while :
do
    case $1 in
    -h)
        cat <<EOF
$usage

OPTIONS
  -h    Display this help and exit
  -b, --branch=BRANCH (defaults: HEAD, main)
  -r, --remote=REMOTE (defaults: upstream, origin)
EOF
        exit $? ;;
    -b) shift && test $# -eq 0 && die <<EOF
$progname: missing argument to \`-b'
$moreinfo
EOF
        branch=$1 ;;
    -b*)
        branch=`expr "X$1" : 'X-b\(.*\)'` ;;
    --branch=*)
        branch=`expr "X$1" : 'X--branch=\(.*\)'` ;;
    -r) shift && test $# -eq 0 && die <<EOF
$progname: missing argument to \`-r'
$moreinfo
EOF
        remote=$1 ;;
    -r*)
        remote=`expr "X$1" : 'X-r\(.*\)'` ;;
    --remote=*)
        remote=`expr "X$1" : 'X--remote=\(.*\)'` ;;
    *)  break ;;
    esac
    shift
done

# Get default values for unsupplied arguments
test "X$branch" = X && {

    branch=$(
        # HEAD is attached (refers to a local branch)
        git symbolic-ref -q --short HEAD ||

        # HEAD is detached at a local branch head
        git for-each-ref --format='%(refname:short)' --points-at HEAD refs/heads ||

        # Default to 'main' or 'master'
        for head in main master
        do
            git show-ref --verify -q refs/heads/$head && {
                echo $head
                break
            }
        done
    )
    if
    then
        : use the branch
    elif git for-each-ref --points-at HEAD refs/heads | grep -q .
    then # HEAD is detached at a local branch head
        if :
        then #
            :
        else
            :
        fi
    elif git for-each-ref --points-at HEAD refs/remotes | grep -q .
    else # HEAD is detached at a remote-tracking branch head
        :
    fi

    # If the ref is not a local branch, spit an error
    headname=`git rev-parse --abbrev-ref "$ref" 2>/dev/null || true`
    git show-ref -q --verify -- "refs/heads/$headname" \
        || die "fatal: ref $ref is not a local branch"

# Display the upstream branch
git for-each-ref --format='%(upstream:short)' "refs/heads/$headname"
    # Branch should be determined by HEAD:
    #
    # If HEAD refers to a local branch
    #    If the local branch has an upstream branch
    set -- (
        # If HEAD is referencing a branch, use that branch
        git symbolic-ref -q HEAD ||
        git for-each-ref --contains HEAD --format='%(refname)' refs/heads
    )
    branch=`git symbolic-ref -q --short HEAD || echo 'main'`
    test "X$branch" = X && branch='main'
}
test "X$remote" = X && {
    remote=`git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null | sed 's#/.*##'`
    test "X$remote" = X && remote='origin'
}

# Validate the arguments
remote_url=`git remote get-url "$remote"`
test "X$remote_url" = X && die "$moreinfo"
git show-ref -q --verify "refs/remotes/$remote/$branch" || die <<EOF
$progname: nonexistent ref: $remote/$branch
EOF

# Determine default branch on remote
remote_HEAD=`git symbolic-ref "refs/remotes/$remote/HEAD" 2>/dev/null | sed 's#.*/##'`
test "X$remote_HEAD" = X && remote_HEAD='main'

# Parse the URL; formats specified git-clone(1)
case $remote_url in
http*://*)
    # http[s]://host.xz[:port]/path/to/repo.git/
    case $remote_url in
    http*://github.com/*.git)
        browse_github ${1+"$@"} ;;
    http*://*bitbucket*/*.git)
        browse_bitbucket ${1+"$@"} ;;
    *)  die "unsupported HTTP remote: $remote_url" ;;
    esac
    ;;
*@*)
    # ssh://[user@]host.xz[:port]/[~[user]/]path/to/repo.git/
    # [user@]host.xz:[/][~[user]/]path/to/repo.git/
    case $remote_url in
    git@github.com:*.git)
        remote_url=`echo "$remote_url" | sed 's|^git@github\.com:|https://github.com/|'`
        browse_github ${1+"$@"} ;;
    git@*bitbucket*:*.git)
        remote_url=`echo "$remote_url" | sed 's|^git@\(.*bitbucket.*\):|https://\1/|'`
        browse_bitbucket ${1+"$@"} ;;
    *)  die "unsupported SSH remote: $remote_url" ;;
    esac
    ;;
git://*)
    # git://host.xz[:port]/path/to/repo.git/
    die 'Git-protocol remotes currently unsupported'
    ;;
/*|file:///*)
    # /path/to/repo.git/
    # file:///path/to/repo.git/
    die 'File-protocol remotes currently unsupported'
    ;;
ftp*://*)
    # ftp[s]://host.xz[:port]/path/to/repo.git/
    die 'FTP remotes currently unsupported'
    ;;
*)  die 'Unrecognized remote protocol'
    ;;
esac
