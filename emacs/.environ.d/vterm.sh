[ "X$INSIDE_EMACS" = Xvterm ] && [ "X$JPY_PARENT_PID" = X ] && {

# Helper function used to send escape sequences to vterm.
# NOTE: This does not appear to work with dash (though bash and zsh are fine).
# NOTE: We do not support running screen inside of tmux.
vterm_printf() {
    case ${TERM%%-*} in
    screen|screen.xterm)
        printf "\eP\e]%s\007\e\\" "$1" ;;
    tmux)
        printf "\ePtmux;\e\e]%s\007\e\\" "$1" ;;
    *)
        printf "\e]%s\e\\" "$1" ;;
    esac
}

# Execute elisp functions directly from vterm. Only functions specified in
# `vterm-eval-cmds` are allowed to be executed.
vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
        vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
        shift
    done
    vterm_printf "51;E$vterm_elisp"
}

# Load aliases that make use of `vterm_cmd` to execute elisp. If present, the
# aliases file was generated by Emacs configuration.
# NOTE: Because `vterm_cmd` executes asynchronously, `cat` may attempt to read
# the file before it has been written by Emacs. To avoid a race condition, we
# use a FIFO for blocking I/O. An alternate implementation that avoids `mkfifo`
# would replace `cat <file>` with `tail -F <file> | head -n 1`.
vterm_load_aliases() {
    local fifo=$(mktemp -up "${TMPDIR:-/tmp}" vterm--user-emacs-directory-XXXX)
    mkfifo "$fifo" && {
        vterm_cmd my/vterm--write-user-emacs-directory "$fifo"
        local user_emacs_directory=$(cat "$fifo")
        rm "$fifo"
        [ -f "$user_emacs_directory/vterm-aliases.sh" ] && . "$user_emacs_directory/vterm-aliases.sh"
    } || {
        echo >&2 'WARNING: could not load vterm-specific shell aliases'
        return 1
    }
}
vterm_load_aliases

# Open the README for vterm.
vterm_help() {
    if [ -f "$EMACS_VTERM_PATH/README.md" ]; then
        vterm_cmd find-file "$EMACS_VTERM_PATH/README.md"
    else
        echo >&2 'ERROR: could not find file: $EMACS_VTERM_PATH/README.md'
        return 1
    fi
}

# Set up directory tracking, prompt tracking, and dynamic buffer title in vterm.
vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}
if [ "$BASH_VERSION" ]
then
    PS1=$PS1'\[$(vterm_prompt_end)\]'
    PROMPT_COMMAND=$(
        printf '%secho -ne "\033]0;%s\007"' \
            "${PROMPT_COMMAND:+$PROMPT_COMMAND; }" \
            "${VTERM_BUFFER_NAME:-*vterm \$HOSTNAME:\$PWD*}"
    )
elif [ "$ZSH_VERSION" ]
then
    setopt PROMPT_SUBST
    PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
    autoload -U add-zsh-hook
    vterm_title() {
        print -Pn "\e]2;${VTERM_BUFFER_NAME:-*vterm %m:%2~*}\a"
    }
    add-zsh-hook -Uz chpwd vterm_title
    vterm_title
else
    echo >&2 'vterm directory tracking and prompt tracking not available for current shell'
fi

# End block
}
