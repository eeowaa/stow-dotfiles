[ "X$INSIDE_EMACS" = Xvterm ] && {

# Helper function used to send escape sequences to vterm.
vterm_printf() {
    if [ -n "$TMUX" ]
    then
        case ${TERM%%-*} in tmux|screen)
            printf "\ePtmux;\e\e]%s\007\e\\" "$1"
        esac
    elif [ "X${TERM%%-*}" = Xscreen ]
    then
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

# Execute elisp functions directly from vterm. Only functions specified in
# `vterm-eval-cmds` are allowed to be executed.
vterm_cmd() {
    local vterm_elisp=
    while [ $# -gt 0 ]
    do
        # The nested $(printf) statements are required in order to handle
        # arguments with spaces in them. For example, `vterm_cmd message "hello world"`
        # only writes "hello" when using a simplified version of the following
        # variable assignment. Ignore your urge to refactor and just go with it.
        vterm_elisp=$vterm_elisp$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')")
        shift
    done
    vterm_printf "51;E$vterm_elisp"
}

# Load aliases that make use of `vterm_cmd` to execute elisp. If present, the
# aliases file was generated by Emacs configuration.
vterm_load_aliases() {
    local dir=$(mktemp -p "${TMPDIR:-/tmp}" -d vterm-XXXX)
    local fifo=$dir/fifo
    if mkfifo "$fifo"
    then
        # Because `vterm_cmd` executes asynchronously, we need to use a FIFO for
        # blocking I/O (otherwise there is a race condition where `cat` tries to
        # read the file before it has been written to by Emacs).
        vterm_cmd my/vterm--write-user-emacs-directory "$fifo"
        local user_emacs_directory=$(cat "$fifo")
        rm "$fifo"
        [ -f "$user_emacs_directory/vterm-aliases.sh" ] && {
            . "$user_emacs_directory/vterm-aliases.sh"
            : 'SUCCESS'
        }
    else
        rmdir "$dir"
        false
    fi || {
        echo >&2 'WARNING: could not find vterm-specific shell aliases'
        return 1
    }
}
vterm_load_aliases

# Open the README for vterm.
vterm_help() {
    if [ -f "$EMACS_VTERM_PATH/README.md" ]
    then
        vterm_cmd find-file "$EMACS_VTERM_PATH/README.md"
    else
        echo >&2 'ERROR: could not find file: $EMACS_VTERM_PATH/README.md'
        return 1
    fi
}

# Set up directory tracking and prompt tracking in vterm.
vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}
if [ "$BASH_VERSION" ]
then
    PS1=$PS1'\[$(vterm_prompt_end)\]'
elif [ "$ZSH_VERSION" ]
then
    setopt PROMPT_SUBST
    PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
else
    echo >&2 'vterm directory tracking and prompt tracking not available for current shell'
fi

# End block
}
