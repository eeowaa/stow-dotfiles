[ "X$INSIDE_EMACS" = Xvterm ] && [ "X$JPY_PARENT_PID" = X ] && {

# Helper function used to send escape sequences to vterm.
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

# Execute elisp functions directly from vterm. Only functions specified in
# `vterm-eval-cmds` are allowed to be executed.
vterm_cmd() {
    local vterm_elisp
    vterm_elisp=""
    while [ $# -gt 0 ]; do
        vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
        shift
    done
    vterm_printf "51;E$vterm_elisp"
}

# Load aliases that make use of `vterm_cmd` to execute elisp. If present, the
# aliases file was generated by Emacs configuration.
vterm_load_aliases() {
    local dir=$(mktemp -p "${TMPDIR:-/tmp}" -d vterm-XXXX)
    local fifo=$dir/fifo
    if mkfifo "$fifo"; then
        # Because `vterm_cmd` executes asynchronously, we need to use a FIFO for
        # blocking I/O (otherwise there is a race condition where `cat` tries to
        # read the file before it has been written to by Emacs).
        vterm_cmd my/vterm--write-user-emacs-directory "$fifo"
        local user_emacs_directory=$(cat "$fifo")
        rm "$fifo"
        [ -f "$user_emacs_directory/vterm-aliases.sh" ] && {
            . "$user_emacs_directory/vterm-aliases.sh"
            : 'SUCCESS'
        }
    else
        rmdir "$dir"
        false
    fi || {
        echo >&2 'WARNING: could not find vterm-specific shell aliases'
        return 1
    }
}
vterm_load_aliases

# Open the README for vterm.
vterm_help() {
    if [ -f "$EMACS_VTERM_PATH/README.md" ]; then
        vterm_cmd find-file "$EMACS_VTERM_PATH/README.md"
    else
        echo >&2 'ERROR: could not find file: $EMACS_VTERM_PATH/README.md'
        return 1
    fi
}

# Set up directory tracking, prompt tracking, and dynamic buffer title in vterm.
vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}
if [ "$BASH_VERSION" ]
then
    PS1=$PS1'\[$(vterm_prompt_end)\]'
    PROMPT_COMMAND=$(
        printf '%secho -ne "\033]0;%s\007"' \
            "${PROMPT_COMMAND:+$PROMPT_COMMAND; }" \
            "${VTERM_BUFFER_NAME:-*vterm \$HOSTNAME:\$PWD*}"
    )
elif [ "$ZSH_VERSION" ]
then
    setopt PROMPT_SUBST
    PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
    autoload -U add-zsh-hook
    vterm_title() {
        print -Pn "\e]2;${VTERM_BUFFER_NAME:-*vterm %m:%2~*}\a"
    }
    add-zsh-hook -Uz chpwd vterm_title
    vterm_title
else
    echo >&2 'vterm directory tracking and prompt tracking not available for current shell'
fi

# End block
}
